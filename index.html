<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Shaft Resistance Capacity of Axially Loaded Piles</title>
    <link rel="icon" href="favicon.ico">
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://pyscript.net/latest/pyscript.css">
    <script defer src="https://pyscript.net/latest/pyscript.js"></script>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <script src="excelProcessor.js"></script>
<!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

</head>

<body>
    <div class="cut">
        <img src="cut.jpg">
    </div>
    <h1>Shaft Resistance Capacity of Axially Loaded Piles</h1>
    <h2 id="myHeader2">Online Calculator</h2>
    <!-- Instructions Icon -->
    <div class="instructions-icon-container">
        <img src="Instructions.jpg" id="instructionsIcon" alt="Instructions" style="cursor:pointer; width:50px; height:auto;">

        <!-- The Modal -->
        <div id="instructionsModal" class="modal">
            <!-- Modal content -->
            <div class="modal-content">
                <span class="close">&times;</span>
                <h2>User Manual</h2>
                
                <h3>System Requirements</h3>
                <p>The calculator is web-based and can be accessed through any modern web browser, including Google Chrome, Mozilla Firefox, Microsoft Edge, and Safari.</p>
                
                <h3>Getting Started</h3>

                <h4>Uploading Data</h4>
                <p>Select a .csv file by clicking the "Upload CSV File" button. Ensure the file follows the specified format as per the provided template, which can be downloaded here.</p>
                
                <h4>Entering Data Manually</h4>
                <p>If you prefer to enter data manually, fill in the pile data, seismic coefficients, number of segments, and soil properties in the respective fields provided on the webpage.</p>
                
                <h3>Using the Calculator</h3>
                <h4>Performing Calculations</h4>
                <p>Input Data: Begin by inputting pile data and seismic coefficients. Run Analysis: Click the "Run" button to perform the calculation. Ensure all required fields are filled.</p>
                
                <h4>Interpreting Results</h4>
                <p>The calculator will display the shaft resistance capacity upon completion.</p>
                
                <h4>Correcting Missing Data</h4>
                <p>If missing data is detected upon CSV upload, the calculator will prompt you to fill in the missing entries. Correct the data as instructed to ensure accurate calculations.</p>
                
                <h3>Reference Table for Soil Properties</h3>
                <p>The calculator provides a reference table with typical soil properties based on SBTn values to aid in data entry.</p>
                
                <h3>Troubleshooting</h3>
                <p>If you encounter issues such as calculations not running or unexpected results, ensure that all data inputs are correct and in the proper format. For persistent issues, contact support using the details provided in the Contact and Support section.</p>
                
                <h3>FAQs</h3>
                <p>Q: What is SBTn? A: The Soil Behavior Type number (SBTn) is a classification method derived from cone penetration test (CPT) data to describe soil behavior. Developed by Peter K. Robertson in 1990, this system aids in identifying soil properties such as cohesion, friction angle and unit weight. 
                    Robertson's work, particularly highlighted in his 1990 publication, provides a comprehensive approach to classifying soils based on their response to CPT, facilitating better design and analysis in the field.

                    Reference:

                    Robertson, P.K. (1990). "Soil classification using the cone penetration test." Canadian Geotechnical Journal, 27(1), 151-158.</p>
                <p>Q: Can I save the results? A: Currently, the results must be manually recorded as the calculator does not offer a save feature.</p>
                
                <h3>Glossary</h3>
                <p>Axially Loaded Piles: Piles subjected to vertical loads along their longitudinal axis.</p>
                <p>Cohesive-Frictional Soils: Soils that exhibit both cohesive and frictional properties.</p>
                <p>Pseudo-Static Conditions: An approximation of dynamic effects, such as earthquake loading, as static forces.</p>
                
                <h3>Contact and Support</h3>
                <p>For technical support, please contact:</p>
                <p>Dr. Lysandros Pantelidis at lysandros.pantelidis@cut.ac.cy</p>
                <p>Dr. Panagiotis Christodoulou at pa.christodoulou@edu.cut.ac.cy</p>
                
                
                <h3>Feedback</h3>
                <p> Please share your suggestions or report any issues to pa.christodoulou@edu.cut.ac.cy</p>
            </div>
            
        </div>
    </div>

    <p>By Drs<strong> <a target="_blank" rel="noopener" href="https://scholar.google.com/citations?user=u5fbtlcAAAAJ&hl=en">Lysandros Pantelidis</a> </strong> and <strong><a target="_blank" rel="noopener" href="https://scholar.google.com/citations?user=R8zAApkAAAAJ&hl=en">Panagiotis Christodoulou</a></strong></p>
    <p><strong>Cite as:</strong><a target="_blank" rel="noopener"> Pantelidis, L. (2022). Shaft resistance capacity of axially loaded piles in cohesive-frictional soils under static or pseudo-static conditions based on ground parameters.</a><a target="_blank" href="Shaft resistance capacity.pdf">(Link) </a></p>
    <div class="container">
        <div class="data-section">
            <table>
                <h2>Pile Data</h2>
                <tbody>
                    <tr>
                        <td>Pile Radius [R]</td>
                        <td><input type="number" id="R" name="Radius" min="0" placeholder="e.g. 0.5 m" step="0.1"></td>
                        <td>m</td>
                    </tr>
                    <tr>
                        <td>Pile Length [L]</td>
                        <td><input type="number" id="H" name="Height" min="0" placeholder="e.g. 10 m" step="0.1"></td>
                        <td>m</td>
                    </tr>
                    <tr>
                        <td>Shear reduction coefficient [ùõºùëñ]</td>
                        <td><input type="number" id="a_i" name="reduction_coefficient" min="0" placeholder="e.g. 1" step="0.5"></td>
                    </tr>
                </tbody>
            </table>
            <table>
                <tbody>
                    <h2>Seismic Coefficients</h2>
                    <tr>
                        <td>Seismic coefficient of horizontal acceleration [Œ±<sub>h</sub>]</td>
                        <td><input type="number" id="ah" name="Horizontal accel" placeholder="e.g. 0.3" step="0.05"></td>
                    </tr>
                    <tr>
                        <td>Seismic coefficient of vertical acceleration [Œ±<sub>v</sub>]</td>
                        <td><input type="number" id="av" name="vertical_acceleration" placeholder="e.g. 0.15" step="0.05"></td>
                    </tr>
                </tbody>
            </table>
            <div class="container">
                <div class="Analysis-section">        
                    <h2>Analysis</h2>   
                    <table>
                        <tbody>
                            <tr>
                                <td>Analysis</td>
                                <td><button class="button" id="submit-button" type="submit" py-Click="results_python()">Run</button></td>
                            </tr>
                            <tr>
                                <td>Preselected values</td>
                                <td><button class="button" type="button" onclick="stored_values()">Preselected values</button></td>
                            </tr>
                            <tr>
                                <td>Clear All </td>
                                <td><button class="button" onclick="clearAll()">Reset </button></td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="container">
                <div class="Upload data">        
                    <h2>Upload .csv file <span style="font-size: 0.8em;">(<a target="_blank" rel="noopener" href="Data template.csv">template</a>)</span></h2>
                    <div class="upload-container">
                        <label for="csvFile">Upload CSV File</label>
                        <input type="file" id="csvFile" accept=".csv" />
                        <button type="button" onclick="handleCSVFileUpload()">Upload</button>
                    </div>
                    <div class="filtering-container">
                        <label>Data Filtering</label>
                        <input type="radio" id="filterYes" name="filterOption" value="yes">
                        <label for="filterYes">Yes</label>
                        <input type="radio" id="filterNo" name="filterOption" value="no" checked>
                        <label for="filterNo">No</label>
                    </div>                        
                    <div id="subgroupInput" style="display: none;">
                        <label for="numSubgroups"> Number of Subgroups:</label>
                        <input type="number" id="numSubgroups" min="2" placeholder="e.g. 5 (preselected)">
                        <label><input type="checkbox" id="filterCohesion" checked> Filter Cohesion (c)</label>
                        <label><input type="checkbox" id="filterFrictionAngle" checked> Filter Friction Angle (œÜ)</label>                       
                    </div>                   
                </div>
            </div>          
                   
            <table>
                <tbody>
                    <h2>Number of Segments</h2>
                    <tr>
                        <td>Number of Segments of each layer</td>
                        <td><input type="number" id="num_seg" name="Number_of_segments" min="0" placeholder="e.g. 5"></td>
                    </tr>
                </tbody>
            </table>
            <table>
                <tbody>
                    <h2>Number of Layers:</h2>
                    <input type="number" id="numLayers" min="1" onchange="generateLayerRows()">
                    <div class="container">
                        <h2>Soil Properties</h2>
                        <table>
                            <thead>
                                <tr>
                                    <th>Œîz (m)</th>
                                    <th>Cohesion, c [kPa]</th>
                                    <th>Friction angle, œÜ [¬∞¬≠¬≠]</th>
                                    <th>Unit weight, Œ≥ [kN/m¬≥]</th>
                                    <!-- <th> SBTn (Robertson 1990)</th> -->
                                </tr>
                            </thead>
                            <tbody id="layersTableBody"></tbody>
                        </table>
                    </div>
                    <script>
                        function generateLayerRows() {
                            var numLayers = document.getElementById("numLayers").value;
                            var tableBody = document.getElementById("layersTableBody");
                            tableBody.innerHTML = ""; // Clear existing rows
                            for (var i = 0; i < numLayers; i++) {
                                var row = document.createElement("tr");
                                var zCell = document.createElement("td");
                                zCell.innerHTML = '<input type="number" id="Z_' + i + '" name="Layer_Height_' + i + '" min="0" placeholder="e.g. 3 m" step="0.5">';
                                row.appendChild(zCell);
                                var cPrimeCell = document.createElement("td");
                                cPrimeCell.innerHTML = '<input type="number" id="c_' + i + '" name="Cohesion_' + i + '" min="0" placeholder="e.g. 20 kPa" step="5">';
                                row.appendChild(cPrimeCell);
                                var phiPrimeCell = document.createElement("td");
                                phiPrimeCell.innerHTML = '<input type="number" id="œÜ_' + i + '" name="Friction_angle_' + i + '" min="0" placeholder="e.g. 30 ¬∞" step="5">';
                                row.appendChild(phiPrimeCell);

                                var gammaCell = document.createElement("td");
                                gammaCell.innerHTML = '<input type="number" id="Œ≥_' + i + '" name="Unit_Weight_' + i + '" min="0" placeholder="e.g. 20 kN/m¬≥"step="5">';
                                row.appendChild(gammaCell);
                                
    //                             if (isCsvUpload) {
    //                                 var SBTCell = document.createElement("td");
    //                                 SBTCell.innerHTML = '<input type="number" id="SBT_' + i + '" name="SBT_' + i + '" min="1" max="9" placeholder="e.g. 1 or blank "step="1">';
    //                                 row.appendChild(SBTCell);
    // }
                                tableBody.appendChild(row);
                            }}
                    </script>
                </tbody>
            </table>
            

           
            <div id="uploadStatus"></div>
            <div id="uploadResults"></div>
            <script>
                function stored_values() {
                    document.getElementById("R").value = "0.5";
                    document.getElementById("H").value = "10";
                    document.getElementById("ah").value = "0";
                    document.getElementById("av").value = "0";
                    document.getElementById("a_i").value = "1";
                    document.getElementById("num_seg").value = "5";
                    document.getElementById("numLayers").value = "2";

                    // Manually trigger the onchange event for numLayers
                    var numLayersInput = document.getElementById("numLayers");
                    if ("createEvent" in document) {
                        var evt = document.createEvent("HTMLEvents");
                        evt.initEvent("change", false, true);
                        numLayersInput.dispatchEvent(evt);
                    } else {
                        numLayersInput.fireEvent("onchange");
                    }
                }
            </script>
        </div>

    </div>
    <script>
        document.getElementById('filterYes').addEventListener('change', function() {
            var subgroupInput = document.getElementById('subgroupInput');
            subgroupInput.style.display = this.checked ? 'inline-block' : 'none';
            });
        document.getElementById('filterNo').addEventListener('change', function() {
        var subgroupInput = document.getElementById('subgroupInput');
        subgroupInput.style.display = 'none';
          });
    
        document.getElementById('submit-button').addEventListener('click', function() {
            var filterYes = document.getElementById('filterYes');
            var numSubgroups = document.getElementById('numSubgroups');
        });
    </script>
<!-- Placeholder for missing data corrections -->
<div id="missingDataSection"></div>
<!-- Placeholder for SBT reference table -->
<div id="sbtReferenceSection"></div>
<script>
    // Get the modal
    var modal = document.getElementById('instructionsModal');
    
    // Get the button that opens the modal
    var btn = document.getElementById('instructionsIcon');
    
    // Get the <span> element that closes the modal
    var span = document.getElementsByClassName('close')[0];
    
    // When the user clicks on the button, open the modal
    btn.onclick = function() {
        modal.style.display = "block";
    }
    
    // When the user clicks on <span> (x), close the modal
    span.onclick = function() {
        modal.style.display = "none";
    }
    
    // When the user clicks anywhere outside of the modal, close it
    window.onclick = function(event) {
        if (event.target == modal) {
            modal.style.display = "none";
        }
    }
    </script>
<py-script>
from js import document, window, alert 
from math import sin, tan, radians, pi, sqrt, asin

#!-- # Define a global variable to track if analysis has been run
#analysis_run = False -->

# Function to perform linear interpolation
def linear_interpolation(data, within_limits):
    interpolated_data = data.copy()
    indices_to_interpolate = [i for i, value in enumerate(within_limits) if not value]
    
    for i in indices_to_interpolate:
        # Find the closest True values before and after the current index
        prev_index = max([idx for idx in range(i, -1, -1) if within_limits[idx]], default=0)
        next_index = min([idx for idx in range(i, len(within_limits)) if within_limits[idx]], default=len(within_limits) - 1)
        
        # Perform linear interpolation
        x0, y0 = prev_index, data[prev_index]
        x1, y1 = next_index, data[next_index]
        interpolated_data[i] = y0 + (y1 - y0) * (i - x0) / (x1 - x0)

    return interpolated_data

def standard_deviation(data):
    n = len(data)
    if n < 2:
        return 0
    mean = sum(data) / n
    variance = sum((x - mean) ** 2 for x in data) / (n - 1)
    return variance ** 0.5

def median(data):
    sorted_data = sorted(data)
    n = len(sorted_data)
    if n % 2 == 0:
        return (sorted_data[n//2 - 1] + sorted_data[n//2]) / 2
    else:
        return sorted_data[n//2]
        
def load_data():
    filter_yes = document.getElementById('filterYes').checked
    filter_no = document.getElementById('filterNo').checked

    num_layers_value = document.getElementById('numLayers').value
    num_layers = int(num_layers_value) if num_layers_value else 1

    num_segments_value = document.getElementById('num_seg').value
    num_segments = int(num_segments_value) if num_segments_value else 5

    num_Subgroups_value = document.getElementById('numSubgroups').value
    num_Subgroups = int(num_Subgroups_value) if num_Subgroups_value else 5
    
    filter_cohesion = document.getElementById('filterCohesion').checked
    filter_friction_angle = document.getElementById('filterFrictionAngle').checked

    pile_data = {
        'R': float(document.getElementById('R').value) if document.getElementById('R').value else 0.5,
        'H': float(document.getElementById('H').value) if document.getElementById('H').value else 10,
        'ah': float(document.getElementById('ah').value) if document.getElementById('ah').value else 0,
        'av': float(document.getElementById('av').value) if document.getElementById('av').value else 0,
        'a_i': float(document.getElementById('a_i').value) if document.getElementById('a_i').value else 1,
    }

    layer_parameters = []
    for i in range(1,num_layers+1):
        Z_id = f'Z_{i}'
        c_id = f'c_{i}'
        phi_id = f'œÜ_{i}'  
        gamma_id = f'Œ≥_{i}' 
        # Get the value of c (cohesion)
        c = float(document.getElementById(c_id).value) if document.getElementById(c_id) else 0
        # Check if c is 0, and if so, set it to a small non-zero value
        if c == 0:
            c = 0.0001
        # Get the value of œÜ_d (friction angle)
        phi_d = float(document.getElementById(phi_id).value) if document.getElementById(phi_id) else 0
        # Check if œÜ_d is 0, and if so, set it to a small non-zero value
        if phi_d == 0:
            phi_d = 0.0001
        if phi_d > 45:
            phi_d = 45      
        # Get the value of Œ≥ (unit weight of soil)
        gamma = float(document.getElementById(gamma_id).value) if document.getElementById(gamma_id) else 0
        # Check if Œ≥ is 0, and if so, set it to a small non-zero value
        if gamma == 0:
            gamma = 0.0001
        layer_data = {
            'Z': float(document.getElementById(Z_id).value) if document.getElementById(Z_id) else 0,
            'c': c,
            'œÜ_d': phi_d,
            'Œ≥': gamma,
        }
        layer_parameters.append(layer_data)
        # Print the c values
    if filter_yes:
        if filter_cohesion:
            c_values = [layer_data['c'] for layer_data in layer_parameters]
            c_groups = [c_values[i:i+num_Subgroups] for i in range(0, len(c_values), num_Subgroups)]
            # Calculate the median and standard deviation for each group
            medians = [median(group) for group in c_groups]
            sample_std_deviations = [standard_deviation(group) for group in c_groups]
            if sample_std_deviations:
                half_si_si_plus_1 = [(sample_std_deviations[i] + sample_std_deviations[i+1]) / 2 for i in range(len(sample_std_deviations) - 1)]
                half_si_minus_1_si_plus_1 = [(sample_std_deviations[i-1] + sample_std_deviations[i+1]) / 2 for i in range(1, len(sample_std_deviations) - 1)]
                half_si_si_minus_1 = [(sample_std_deviations[i] + sample_std_deviations[i-1]) / 2 for i in range(1, len(sample_std_deviations))]
            else:
                # Handle the case when sample_std_deviations is empty
                half_si_si_plus_1 = []
                half_si_minus_1_si_plus_1 = []
                half_si_si_minus_1 = []
            # Initialize the data list with the first group's data, which doesn't have the two previous std devs
            data_in_columns_with_min = [(round(half_si_si_plus_1[0], 3), 'None', 'None', round(half_si_si_plus_1[0], 3))]
            # Add the rest of the data with the calculated minimum values
            for i in range(1, len(half_si_si_plus_1)):
                min_value = round(min(
                    half_si_si_plus_1[i],
                    half_si_minus_1_si_plus_1[i-1] if i-1 < len(half_si_minus_1_si_plus_1) else float('inf'),
                    half_si_si_minus_1[i-1]), 3)
                data_in_columns_with_min.append((round(half_si_si_plus_1[i], 3), 
                                                round(half_si_minus_1_si_plus_1[i-1], 3) if i-1 < len(half_si_minus_1_si_plus_1) else 'None', 
                                                round(half_si_si_minus_1[i-1], 3) if i-1 < len(half_si_si_minus_1) else 'None', 
                                                min_value))
            # Add the last group which doesn't have the next std devs
            last_group_min_value = round(half_si_si_minus_1[-1], 3)
            data_in_columns_with_min.append(('None','None', last_group_min_value,last_group_min_value))
            # Calculate Md+Sd and Md-Sd for each group
            md_plus_sd = [round(medians[i] + data_in_columns_with_min[i][3], 3) for i in range(len(medians))]
            md_minus_sd = [round(medians[i] - data_in_columns_with_min[i][3], 3) for i in range(len(medians))] 
            # Check if each data point is within Md+Sd and Md-Sd and create the table data
            table_data = []
            for group_index, (group, md_p_sd, md_m_sd) in enumerate(zip(c_groups, md_plus_sd, md_minus_sd)):
                for data_point in group:
                    within_limits = md_m_sd <= data_point <= md_p_sd
                    table_data.append([group_index+1, data_point, within_limits])
            # Perform linear interpolation on the data points
            within_limits = [item[2] for item in table_data]
            # Perform linear interpolation on the data points
            interpolated_data = linear_interpolation(c_values, within_limits)
            # Update layer parameters with interpolated c values
            for i, layer_data in enumerate(layer_parameters):
                layer_data['c'] = interpolated_data[i]
            # Print the interpolated data
            print("Filtered Cohesion Data:")
            print(interpolated_data)    
            
        if filter_friction_angle:
            phi_values = [layer_data['œÜ_d'] for layer_data in layer_parameters]
            phi_groups = [phi_values[i:i+num_Subgroups] for i in range(0, len(phi_values), num_Subgroups)]
            phi_medians = [median(group) for group in phi_groups]
            phi_std_deviations = [standard_deviation(group) for group in phi_groups]
            if phi_std_deviations:
                half_si_si_plus_1_phi = [(phi_std_deviations[i] + phi_std_deviations[i+1]) / 2 for i in range(len(phi_std_deviations) - 1)]
                half_si_minus_1_si_plus_1_phi = [(phi_std_deviations[i-1] + phi_std_deviations[i+1]) / 2 for i in range(1, len(phi_std_deviations) - 1)]
                half_si_si_minus_1_phi = [(phi_std_deviations[i] + phi_std_deviations[i-1]) / 2 for i in range(1, len(phi_std_deviations))]
            else:
                half_si_si_plus_1_phi = []
                half_si_minus_1_si_plus_1_phi = []
                half_si_si_minus_1_phi = []
            # Initialize œÜ_d data with min values, akin to c value processing
            data_in_columns_with_min_phi = [(round(half_si_si_plus_1_phi[0], 3), 'None', 'None', round(half_si_si_plus_1_phi[0], 3))]
            for i in range(1, len(half_si_si_plus_1_phi)):
                min_value_phi = round(min(
                    half_si_si_plus_1_phi[i],
                    half_si_minus_1_si_plus_1_phi[i-1] if i-1 < len(half_si_minus_1_si_plus_1_phi) else float('inf'),
                    half_si_si_minus_1_phi[i-1]), 3)
                data_in_columns_with_min_phi.append((round(half_si_si_plus_1_phi[i], 3), 
                                                    round(half_si_minus_1_si_plus_1_phi[i-1], 3) if i-1 < len(half_si_minus_1_si_plus_1_phi) else 'None', 
                                                    round(half_si_si_minus_1_phi[i-1], 3) if i-1 < len(half_si_si_minus_1_phi) else 'None', 
                                                    min_value_phi))
            last_group_min_value_phi = round(half_si_si_minus_1_phi[-1], 3)
            data_in_columns_with_min_phi.append(('None', 'None', last_group_min_value_phi, last_group_min_value_phi))
            md_plus_sd_phi = [round(phi_medians[i] + data_in_columns_with_min_phi[i][3], 3) for i in range(len(phi_medians))]
            md_minus_sd_phi = [round(phi_medians[i] - data_in_columns_with_min_phi[i][3], 3) for i in range(len(phi_medians))]
            # Check if each œÜ_d data point is within Md+Sd and Md-Sd
            table_data_phi = []
            for group_index, (group, md_p_sd, md_m_sd) in enumerate(zip(phi_groups, md_plus_sd_phi, md_minus_sd_phi)):
                for data_point in group:
                    within_limits_phi = md_m_sd <= data_point <= md_p_sd
                    table_data_phi.append([group_index+1, data_point, within_limits_phi])
            # Perform linear interpolation on the œÜ_d data points
            within_limits_phi = [item[2] for item in table_data_phi]
            interpolated_phi = linear_interpolation(phi_values, within_limits_phi)
            for i, layer_data in enumerate(layer_parameters):
                layer_data['œÜ_d'] = interpolated_phi[i]
            print("Filtered Friction Angle Data:")
            print(interpolated_phi)
                        
    return pile_data, layer_parameters, num_segments

   
def divide_layers_into_segments(layer_parameters, num_segments):
    segmented_layers = []

    accumulated_height = 0  # Initialize accumulated_height for accurate Z_UP and Z_DOWN calculation

    for layer_data in layer_parameters:
        layer_Z = layer_data['Z']
        segment_height = layer_Z / num_segments
        Z_DOWN = accumulated_height  # Initialize Z_DOWN for accurate Z_UP calculation

        for i in range(num_segments):
            segment_data = layer_data.copy()
            Z_UP = Z_DOWN  # Set Z_UP to previous Z_DOWN
            Z_DOWN += segment_height
            segment_data['Z'] = segment_height
            segment_data['Accumulated Height'] = Z_DOWN
            segment_data['Layer'] = layer_parameters.index(layer_data) + 1
            segment_data['Z_UP'] = Z_UP
            segmented_layers.append(segment_data)

        # Update accumulated_height for the next layer
        accumulated_height = Z_DOWN

    return segmented_layers    

def calculate_coefficients(pile_data, segment_data, z_value):
    if z_value == 0 or segment_data['Accumulated Height'] == 0:
        return 0, 0, 0  # Set K_OE to 0 if z_value or Accumulated Height is 0
    
    œÜ_r = radians(segment_data['œÜ_d'])
    ah_av = pile_data['ah'] / (1 - pile_data['av'])
    Rankine_A = (1 - sin(œÜ_r)) / (1 + sin(œÜ_r))
    Rankine_P = 1 / Rankine_A
    Jaky = 1 - sin(œÜ_r)
    mA = 1
    ŒæA = (mA - 1) / (mA + 1) - 1

    A0_A = (Rankine_A * (1 - ŒæA * sin(œÜ_r) + ah_av * tan(œÜ_r) * (2 + ŒæA * Jaky)))

    if A0_A <  1:
        Œª = 1
    else:
        Œª = 0

    two_Œª_1 = (2 * Œª - 1)
    B1_A = ((two_Œª_1 * 2 * segment_data['c'] / ((1 - pile_data['av']) * (segment_data['Œ≥'] * z_value))) * tan(pi / 4 - œÜ_r / 2))

    e1 = ((1 - A0_A) / B1_A)
    e2 = (1 + A0_A) / (two_Œª_1 * B1_A) + 2 * segment_data['c'] / ((1 - pile_data['av']) * segment_data['Œ≥'] * z_value * two_Œª_1 * B1_A * tan(œÜ_r))

    Œ±0 = (1 + (e2 ** 2) * (tan(œÜ_r)) ** 2)
    b0 = (1 - (2 * two_Œª_1 * e1 * e2 + e2 ** 2) * (tan(œÜ_r)) ** 2)
    c0 = (e1 ** 2 + 2 * two_Œª_1 * e1 * e2) * (tan(œÜ_r)) ** 2
    d0 = (-e1 ** 2 * (tan(œÜ_r)) ** 2)

    D0 = (b0 ** 2 - 3 * Œ±0 * c0)
    D1 = (2 * b0 ** 3 - 9 * Œ±0 * b0 * c0 + 27 * Œ±0 ** 2 * d0)
    IMSQRT = ((((D1 ** 2) - (4 * (D0 ** 3)))) ** 0.5)
    D1_sqrt = ((D1 - IMSQRT) / 2)
    C0 = (D1_sqrt ** (1 / 3))
    Œ∂ = complex(-0.5, (sqrt(3)) / 2)
    Œ∂_Œª_C0 = ((Œ∂ ** Œª) * C0)

    twoŒª_1_3Œ±0 = (-1 / (3 * two_Œª_1 * Œ±0))

    D0_Œ∂ŒªC0 = (D0 / Œ∂_Œª_C0)

    bo_Œ∂ŒªC0 = (b0 + Œ∂_Œª_C0 + D0_Œ∂ŒªC0)

    colV_colX = (bo_Œ∂ŒªC0.real * twoŒª_1_3Œ±0.real)

    œÜm = (asin(colV_colX))
    œÜm_deg = (œÜm * (180 / pi))

    cm_o = (segment_data['c'] * tan(œÜm) / tan(œÜ_r))

    Œö_OE = ((1 - two_Œª_1 * sin(œÜm)) / (1 + two_Œª_1 * sin(œÜm)) - two_Œª_1 * 2 * cm_o * tan(pi / 4 - two_Œª_1 * œÜm / 2) / (segment_data['Œ≥'] * z_value * (1 - pile_data['av'])))
    œÉ_ŒßŒï = (Œö_OE * (1 - pile_data['av']) * segment_data['Œ≥'] * z_value)

    return Œö_OE, œÜm_deg, œÉ_ŒßŒï

def print_table(table_data, headers):
    # Find the maximum width for each column
    col_widths = [len(header) for header in headers]
    for row in table_data:
        for idx, cell in enumerate(row):
            col_widths[idx] = max(col_widths[idx], len(str(cell)))

    # Create a format string with dynamic padding
    row_format = " | ".join(["{:<" + str(width) + "}" for width in col_widths])

    # Print the header
    print(row_format.format(*headers))
    print("-" * (sum(col_widths) + len(col_widths) * 3 - 1))  # Adjust for the separators

    # Print the rows
    for row in table_data:
        print(row_format.format(*row))
        
def results_python():
    # global analysis_run  # Use the global variable

    # Check if analysis has already been run
    #if analysis_run:
        #alert("Analysis has already been run. Please refresh the page to perform a new calculation.")
        #return

    # Set analysis_run to True since analysis is being run now
    #analysis_run = True 

    pile_data, layer_parameters, num_segments = load_data()
    segmented_layers = divide_layers_into_segments(layer_parameters, num_segments)

    # Prepare the header
    headers = ["Layer", "Z Up [m]", "K OE, Up", "Z Down [m]", "K OE, Down", "Average K OE", "Delta z [m]", "Z Average [m]", "QS [kN]"]
    header_row = " | ".join(headers)
    print(header_row)
    print("-" * len(header_row))  # Divider

    total_QS = 0
    total_QS_total=0
    for segment in segmented_layers:
        K_OE_up, _, _ = calculate_coefficients(pile_data, segment, segment['Z_UP'])
        if K_OE_up  <  0:
            K_OE_up = 0  # Set negative K_OE to zero
        K_OE_down, _, _ = calculate_coefficients(pile_data, segment, segment['Accumulated Height'])
        if K_OE_down < 0:
            K_OE_down = 0  # Set negative K_OE to zero
        avg_K_OE = (max(K_OE_up, 0) + max(K_OE_down, 0)) / 2
        delta_x = segment['Accumulated Height'] - segment['Z_UP']
        z_average = (segment['Z_UP'] + segment['Accumulated Height']) / 2
        QS = pi * 2 * pile_data['R'] * delta_x * pile_data['a_i'] * (segment['c'] + avg_K_OE * segment['Œ≥'] * z_average * tan(radians(segment['œÜ_d'])))
        Qs_for_tot = QS / (pi * (pile_data['R'] ** 2))

        total_QS += QS
        total_QS_total += Qs_for_tot

 
   

        # Print each segment's results in a row
        data_row = [str(segment['Layer']), f"{segment['Z_UP']:.2f}", f"{K_OE_up:.3f}", f"{segment['Accumulated Height']:.2f}",
                    f"{K_OE_down:.3f}", f"{avg_K_OE:.3f}", f"{delta_x:.2f}", f"{z_average:.2f}", f"{QS:.2f}"]
        print("        ".join(data_row))

    # Print total QS at the end
    print("-" * len(header_row))  # Divider for total
    print(f"Total QS: {total_QS:.2f} kN")
    print(f"q_s,tot: {total_QS_total:.2f} kPa")
    
    
    
    </py-script>
</body>
</html>        


